<!DOCTYPE html>
<html>
<head>
  <title>Laskuharjoitukset viikolle 3</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <h1>Laskuharjoitukset viikolle 3</h1>

  <h2>Algoritmien kirjoittaminen javascriptillä</h2>

        <p>Algoritmien kirjoittaminen javascriptillä, ei ole oikeastaan sen kummempaa kuin muullakaan ohjelmointikielellä,
          mutta JS:n käyttö algoritmiikassa ei ole aloittijoille. <br>
          Kuten viikon 2. laskuharjoituksissa todettiin, on tyyppiturvallisuus javascriptissä huonolla tasolla.
          Tämä voi aiheuttaa onglemia, mikäli ohjelmoija ei voi olla varma annetun datan tyypistä. Mikäli algoritmi vaatii
          tiettyä datatyyppiä tai tiettyä muotoa on tärkeää validoida syöte ennen sen ajamista algoritmin läpi.
          Tämä toki lisää ylimääräistä boilerplate koodia ohjelmaan. </p>
          <p>Huomattavasti edellistä suurempi riski aloittelevalle JS ohjelmoijalle on tyyppioperaatiot.
            Javascriptissa '5 + 1' voi olla tulkintatavasta liittyen joko '51' tai 6. Tämä aiheuttaa varsinkin aloittelevalle ohjelmoijille
            harmaita hiuksia. </p>
            <p> Tyyppittömyydellä on tietysti myös hyötynsä. Koska kaikki asiat ovat pohjimmiltaann objecteja. Voidaan asioita esimerkiski sortata
              miettimättä sen enempää mitä arvoja ollaan sorttaamassa. Kätevää on myös esimerkiksi compare function toteuttaminen lukuarvoille: </p>
              <code>function compareNumbers(a, b) {
                return a - b; }</code>
                Tämä vertailee tehokkaasti niin tauloita joissa on numeroita, kuin StringNumeroita.
                <code></p>
                  var numericStringArray = ['80', '9', '700'];
                  <br>
                  var numberArray = [40, 1, 5, 200];
                  <br>
                  var mixedNumericArray = ['80', '9', '700', 40, 1, 5, 200];
                </p>
                <p>
                  numberArray: 40,1,5,
                  <br>
                  Sorted without a compare function: 1,200,40,5
                  <br>
                  Sorted with compareNumbers: 1,5,40,200
                </p>
                numericStringArray: 80,9,700
                <br>
                Sorted without a compare function: 700,80,9
                <br>
                Sorted with compareNumbers: 9,80,700
                <p>
                  mixedNumericArray: 80,9,700,40,1,5,200
                  <br>
                  Sorted without a compare function: 1,200,40,5,700,80,9
                  <br>
                  Sorted with compareNumbers: 1,5,9,40,80,200,700
                </p>
              </code>
                <p>Kuten ylhäällä kuitenkin huomataan normaali Javascriptin <code> Array.sort()</code> ei myöskään aina toimi.</p>
              <p>Javascriptin käyttö myöskin haasteellista, tarkkaa liukulukujakäyttävässä laskennassa, jossa javascriptissä toisinaan tapahtuviin
                pyöristelyvirheisiin ei ole varaa. <p>
                  <p><b>En oo varma tästä kappaleetas
                    nopee googlailu kertoi näin, mutta en uskalla väittää varmaksi</b><br>
                    Javascriptin suoritusnopeudet eivät myöskään ole lähelläkään C:n tai C++:n luokkaa, mutta JS voitaa varsinkin NodeJS:llä ajettuna
                    yleensä useita ohjelmointikieliä, kuten esimerkiksi Rubyn, PHP:n ja Pythonin. Tässä kohdin on hyvä muistaa, että algoritmien suoritusnopeus
                    kullakin kielellä riippuu myös paljon suoritettavasta algoritmistä.</p>
                    <p>Lopuksi:<br>
                      JS:n vahvuus algoritmiikassa on kielen monimuotoisuus ja tyypittömyys, mutta sen käyttö vaatii osaamista ja JavaScriptin hyvää ymmärtämistä.
        
        <!-- Matin osuus. Palautetta ja ehdotuksia sekä lisäyksiä kiitos :p -->      
	<h2>Imperatiivinen- ja funktionaalinen ohjelmointi JavaScriptissä</h2>
	        
		<p>Aloittelevat JavaScript ohjelmoijat useimmiten tukeutuvat imperatiiviseen ohjelmointiin. Imperatiivinen ohjelmointi on varsin toimiva sellaisenaan, mutta saa oivia lisätyökaluja funktionaalisesta ohjelmoinnista. Esimerkkinä imperatiivisesta ohjelmointikielestä on esimerkiksi Java, C sekä python. Funktionaalisia edustaa esimerkiksi Scala tai Clojure.
		</p>
		<p>JavaScriptillä on valmiina monia funktioita ja työkaluja.  Esimerkkinä:<br> 
			<code>eval("koodia") <br>
			isFinite(arvo) <br>
			parseInt("tekstiä") <br>
			</code> <br>
		Funktioita, niin valmiita kuin omiakin, voi halutessaan muokata esimerkiksi bind-metodilla. Tätä kutsutaan funktion osittain soveltamiseksi. Funktioita voi lennosta asettaa, muokata ja kopioida eri muuttujiin varsin lennokkaasti ilman suuria muutoksia koodiin. Esimerkiksi: <br>
			<code>var summa = function (a,b) {return a + b}; <br>
			var summa_5 = summa.bind(null, 5); <br>
			</code> <br>
		Funktionaalinen ohjelmointi perustuu suurimmilta osin rekursioon joka lyhentää koodia. Viimeisimpiä uudistuksia on myös lamda-syntaksi. Näiden kautta funktionaalinen ohjelmointi on lyhyempää, tuoden vähemmän rivejä testattavaksi.
		</p>
		<p>Funktioilla pystyy osan JavaScriptin muuttujen ja näkyvyys ongelmista poistaa. Se ei ole riippuvainen sen ulkoisista muuttujista, enintään parametreistaan. Imperatiivinen ohjelmointi voi huolimattomuudessaan muuttaa joitakin olennaisia muuttujia ylikirjoittamalla, esimerkiksi saman nimisiä muuttujia. Ilmiötä kutsutaan sivuvaikutuksiksi (side effects). Funktiolla ei samaa ongelmaa ole sillä sen näkyvyysaluetta, funktion sisäpuolella olevia muuttujia eivät muut ylikirjoita jollei niihin implisiittisesti viitata funktion kutsuvaiheessa. Tämäkin vaikutus on vain kyseiselle yksittäiselle funktion kutsukerralle. Esimerkiksi:
			<code> <br>
			var a = 9002; <br>
			write(a); //tulostaa 9002 <br>
			<br>
			function puolita(x) { <br>
				var a = x/2; <br>
				write(a); <br>
			}; <br>
			
			puolita(a); //4501 <br>
			write(a); //9002 <br>
			</code> <br>
		</p>
		<p>Lopuksi:<br>
		Funktionaalisella ohjelmoinnilla on käyttönsä ja hyötynsä koodin rakenteen parantamiseksi. Imperatiivinen ohjelmointi on kuitenkin monelle intuitiivisempaa ja usein luettavampaa. Tämän ja edellä mainituista syistä imperatiivinen ohjelmointi jossa hyödynnetään JavaScriptin funktionaalisia ominaisuuksia, lienee JS:n parhaimpia käyttötapoja.
		</p>
	<h2>Poikkeustenkäsittely</h2>
		<p>JavaScriptissä poikkeukset tyypillisimmin käsitellään Javasta tutulla try-catch-finally- tavalla sekä heittämällä komento throw. Try-catch-finally- tavan voi toteuttaa kolmella eri tapaa:</p>
					<ol>
						<li>try...catch</li>
                 	<li>try...finally</li>
                	<li>try..catch...finally</li>
               </ol>                 
                 
      <p>Throw- komentoa voi heittää JavaScriptissä paljon vapaammin, kuin Javassa. Tässä esimerkki perus try-catch- lauseessa:</p>
			<code>
			try{ <br>
				throw "Poikkeus"	<br>		
			}<br>
			catch(e){<br>
			alert(e.message) // Virheviesti <br>
			}<br>
				</code>              
      <p>Esimerkissä throw ohjaa poikkeuksen suoraan catch:ille. Tämä esimerkki on myös ehdoton try-catch- käsittely, missä catch-lauseita on vain yksi. JavaScriptissä on myös mahdollisuus tehdä ehdollinen try-catch-käsittely, missä voi olla useampi catch-lause tai catch-lauseen sisälle syöttää useampi else if- vaihtoehto poikkeukselle. Tämä ei ole EcmaScript 6:n mukainen menettelytapa ja muutenkin monimutkaistaa sekä pidentää JavScript- koodia huomattavasti, 
      joten emme suosittele käyttämään ehdollisia try-catch- käsittelyjä.  </p>
      <p>Finally- lausetta voidaan käyttää, jos halutaan poikkeuksen päättyvän kunniakkaasti, esimerkiksi jos on tarve vapauttaa resursseja, 
      joita try-catch- komento on varannut käyttöönsä. </p>
      	<code>
      	avaaTiedosto()<br>
			try{ <br>
				kirjoitaTiedostoon(data)	<br>		
			}<br>
			catch(e){<br>
			käsittelePoikkeus(e) // Virheviesti <br>
			}<br>
			finally{<br>
			suljeTiedosto()<br>
			}<br>
				</code>   
      <p>Mitä Throw-komentoon tulee, voi sillä vapaasti heitellä erityyppisiä attribuutteja. Yksi vaihtoehto on heittää funktio: </p>
      <code>
			try{ <br>
				throw function(){alert("Nyt meni pieleen")}	<br>		
			}<br>
			catch(e){<br>
			e // Nyt meni pieleen <br>
			}<br>
				</code>   
				<p>Paras tapa olisi kuitenkin käyttää Error- konstruktorifunktion luomaa oliota, jolloin sekä heitetyt että JavScriptin omat poikkeukset toimivat samalla tavalla. Tästä esimerkki: </p>
		<code>
			try{ <br>
				throw new Error("Nyt meni pieleen")	<br>		
			}<br>
			catch(e){<br>
			alert(e.message) // Viesti: Nyt meni pieleen <br>
			}<br>
				</code>                
              </body>
              </html>
