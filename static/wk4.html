<!DOCTYPE html>
<html>
<head>
  <title>Laskuharjoitukset viikolle 4</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <h1>Laskuharjoitukset viikolle 4</h1>

  <div><h2>Oliot</h2>
    <h3>Olioista ja niiden luonnista yleisesti</h3>
    Olioiden luontiin on JavaScriptissä kielelle tyypillisesti useita erilaisa
    tapoja, joista ei suoranaisesti voida sanoa toisen olevan toista parempi.
    Kaikilla tavoilla on omat vahvuutensa ja heikkoutensa. Käydää tässä läpi
    muutamia erilaisia tapoja luoda olioita JavaScriptissä.</div>
    <div>Yksinkertaisin tapa on luoda objecti literaali sanomalla
      <pre><code>  var person = {
        name : "Anssi",
        getName : function (){
            return this.name
        }
    }</pre></code>
    Tämä luo yhden olion, jolla on yksi arvo ja yksi funktiokutus. Tälle oliolle
     ei juurikaan voi luoda uusia instansseja. Tämä on nopea ja yksinkertainen tapa
     luoda olioita, joita ei tarvitse luoda useita.

    </div>
    <div> Javamaisesti olioiden luominen konstruktorin kautta tapahtuu JavaScriptissä
      itseasiassa functio kutsulla.
      <pre><code>function Person(name){
      this.name = name
      this.getName = function(){
        return this.name
      }
    }</pre></code>
    Luomme function, jolle annamme tässä tapauksessa parametriksi nimen ja saamme
    return arvona uuden olion annetuilla parametreillä. Tällä tyylillä on javamainen
    hyöty ja kyky luoda uusia samankaltaisia oloita erilaisilla arvoilla.
    </div>
    <div>Entäs sitten ne sekavat prototyypit?
    <pre><code> function Person(){};
    Person.prototype.name = "Anssi";</pre></code>
    Tässä luomme vain function Person(), aivan kuten loimme javamaisella konstruktorillamme
  mutta jätämmä kaikki kentät tyhjiksi! Koska JavaScriptin oliot ja functiot perivät kaikki
kenttänsä ylemmiltä Object functioilta, niin tyhjänki olion luominen luo meille object ominaisuudet
täyttävän Olion. Nyt voimme tähän "olemattomaan" olioomme lisätä kenttiä prototype ominaisuuden avulla
Tämä lisää halutun ominaisuuden kaikkiin tällä konstruktorilla luotuihin olioihin.
</div>
<div>Protypeä ja javamaista konstruktoria voi tietenkin JavaScriptmäiseen tyyliin yhdistellä
<pre><code>function Person(name){
      this.name = name;
    }
    Person.prototype.getName = function(){
      return this.name
    }</pre></code>
    Tässä luomme function Person ja annamme sille parametrillä nimen ja lisäämme myöhemmin
    lennosta jokaiselle luotavalle oliolle myös oman function "getName".
    
    <p>
      Etuna erillisillä prototypeillä verrattuna että kaikki olisi funktion sisällä sidottuna this:llä on, että this:llä kaikki metodit luodaan jokaiselle oliolle erikseen kun taas prototypellä ne viittaavat vain samoihin muistipaikkoihin. Eli muistin hallinnan kannalta on pientä etua käyttää prototypeä metodien luomiseen. Onko oikein käyttää sanaa metodi viitattaessa javascript funktio-luokkien omiin funktioihin en tiedä, mutta käytän silti.
    </p>
  </div>
  <div>
    <h3>Olioiden attribuuteista</h3>
    Olioiden arvojen muokkaaminen tapahtuu varsin dynaamisesti. Tämä tuo niin uhkia kuin
    mahdollisuuksia olioiden käsittelyyn. Olioiden arvoja voidaan kutsua yksinkertaisuudessaan pistesyntaksilla.
    <pre><code> olio.name = "Matti" // olio.name = Matti
      olio.name = "Esko" // olio.name = Esko
      olio.neim = "Kalle" // olio.name = Esko, olio.neim = "Kalle"
    </pre></code>
    Jos attribuutti-name on olemassa, muokataan sitä. Päinvastaisessa tapauksessa luodaan uusi attribuutti oliolle
    kyseisellä nimellä. Tämä altistaa monille kirjoitusvirheille, sillä koodin ohjelman voi suorittaa vaikka nimesitkin
    antamasi attribuutin väärin.
  </div>
  <div>
    Tietysti tämän välttämiseksi voi määrittää oliolle get- ja set-metodit. Käytännössä se onnistuu määrittelemällä
    oliolle kyseiset funktiot, kuten ylemmässä Person-esimerkissä mainittiin. Tällöin voidaan tarkemmin määrittää
    ehdot esimerkiksi muuttujan muuttamiselle. Kuitenkaan näiden määrittely ei sulje suoraan olion attribuuttien
    suoraan muuttamista.
    Oletetaan esimerkissä että setterissämme on tarkastus, että syöte on merkkijono.
    <pre><code> olio.setName("Harri") // name = Harri
      olio.setName(39) // name = Harri, Syöte ei ole merkkijono!
      olio.name = 42 // name = 42</pre></code>
  </div>
  <div>
    Osittain tämä voidaan korjata määrittämällä prototyypin tai luokan käyttäytymistä kyseisen attribuutin kohdalla.
    Esimerkiksi voitaisiin antaa attribuutille ikä ainoastaan positiivisia lukuja funktion avulla.
    <pre><code><b>Object.defineProperties(olio {
      "ikä": { set: asetaPositiivinenLuku (this, x) }
      });</b>

      olio.ikä = 51 // ikä on 51
      olio.ikä = "kirahvi" //ikä on edelleen 51 tarkastusfunktiomme vuoksi
      olio.ikä = 52 // ikä on 52
    </pre></code>
  </div>
  <div>
    Arvoja voidaan tarvittaessa määrittää muokkaamattomaksi jos on tärkeää jonkin attribuutin pysyvyys.
    <pre><code>function Person(name, id){
        this.id = id;
        <b>Object.defineProperty(this, 'id', {writable: false});</b>
        this.name = name
        this.getName = function(){
          return this.name
        }
      }</pre></code>
    Nyt attribuutti id on suojattu. Ratkaisuna tämäkin on osittainen, sillä id on voidaan määrittää taas muokattavaksi
    vastaavalla metodilla.
  </div>
  <br/>
  <div>Tänne voisi varmaan lisäillä olioiden arvojen muokkauksesta, lisää luonnista
    tai private/public näkymästä, tai mitä nyt ikinä keksittekään! Ja insa voi taas tulla refaktroimaan
    kaiken mitä mä oon tehnyt.
    -Lesandre
      Hue! Kirjottelin olioiden muokkaamisesta. Muuttaa saa wapaasti. -Sieni
  </div>
  
  <div>
    <h3>Luokka-luokat</h3>
    <p>
    EcmaScript 6:ssa esitellään valmiit 'luokka-Luokat'. Ne eivät ole vielä natiivisti tuettuja selaimissa, mutta back-endissä ne saa käyttöön uusimmissa node-versioissa käyttämällä 'use strict'-avainsanaa tiedoston alussa. Frontin puolella on käytettävä erillistä kirjastoa kuten Babelia tai Traceuria koodin muuttamiseen takaisin ES5:ksi.
    </p>
    
    <pre>
      <code>
'use strict'
class Luokanperkele {
	constructor(nimi) {
		this.nimi = nimi;
		this.heimo = 'jotainhyvingeneeristä';
	}
	
	tassapahienometodi() {
		console.log('olen ' + nimi + ' ja kuulun heimoon ' + this.heimo);
	}

	_olenyksityinen() { }
} 
      </code>
    </pre>
    
    <p>
      Ja kuten voi nähdä ne koostuvat normaaleista luokan elementeistä kuten konstruktorista ja metodeista. Huomioitavaa on että kaikki metodit ovat publiceja ja kaikki muuttujat ja metodit ovat aina käytettävissä luokan ulkopuolelta. Private-metodien tai muuttujien luomiseen on käytettävä duck-typingia eli lisättävä vaikkapa alaviiva _ nimen eteen.
    </p>
    
    <p>
      Javascript sinänsä on ollut vähän kumma kieli ettei luokkia ole toteuttu aikaisemmin kuin edellä mainituilla hieman 'häx'-tavoilla. Siinä saa aloittelija hieman raapia päätään kun haluaa tehdä luokkia javascriptissa ja jotka ovat maksimaalisen suorituskykyisiä. Valmiit luokat lopettavat tuon ylimääräisen miettimisen ja antavat valmiin aihion, jota voidaan käyttää nykyisten funktio-hässäköiden sijasta. Tämä tuo koheesiota koko javascript koodaukseen, koska käytännöt luokkien luomiseen tuntuvat vaihtelevan jokaisessa projektissa. Koko luokka sinänsä on pelkkää syntactic sugaria ja sisäisesti ne ovat edelleen samaa prototype-funktioiden ja Objectien sotkua jota olemme tottuneet näkemään.
    </p>
    
    <p>
      Valmiit luokat luovat paljon eriäviä mielipiteitä javascript-yhteisössä ja ne tuovat omat murheensa koodiin. Onkin siis ohjelmoijan itse tiedettävä milloin olisi pitäydyttyvä funktioissa ja milloin taas luokkien käyttö on suotavaa. Mutta kyllä ne ovat ihan jees.
    </p>
  </div>
</body>
</html>
